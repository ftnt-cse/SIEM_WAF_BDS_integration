#!/usr/bin/env python

from __future__ import absolute_import
from pexpect import pxssh
import os, sys, re, logging, pexpect, base64, requests
import xml.etree.ElementTree as xml
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


# default logging level is CRITICAL, change level to DEBUG if needed
logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
#logging.basicConfig(stream=sys.stderr, level=logging.CRITICAL)

#
# Some constants to set according to your environment
#
# file upload location
base_directory = '/var/www/html/upload'
server_ip = 'WebServer_IP'
server_username = 'admin'
server_password = base64.b64decode('') # not a serious protection though
fgt_username = 'admin'
fgt_password = base64.b64decode('') # not a serious protection though
ban_period = '1200'
fgt_ip = 'FortiGate_IP'

# Ban the source IP on FortiGate for the next ban_period seconds
def ban_ip(fgt_ip, banip):
    r = requests.session()
    data = {'username': ''+fgt_username+'', 'secretkey': ''+fgt_password+''}

    try:
        r = requests.post('https://' + fgt_ip + '/logincheck', data=data, verify=False)
        for cookie in r.cookies:
            if cookie.name == 'ccsrftoken':
                csrftoken = cookie.value[1:-1]
                r.headers.update({'X-CSRFTOKEN': csrftoken})
                r.headers.__delitem__('Transfer-Encoding')
        params = {'vdom': 'root',"expiry": ban_period, 'ip_addresses': "[" + '\"' + banip + '\"' + "]"}
        t = requests.post('https://' + fgt_ip + '/api/v2/monitor/user/banned/add_users', cookies=r.cookies,
                          headers=r.headers, params=params, verify=False)
        logging.debug(t.content)
    except requests.ConnectionError:
        print("Connection error, check if the FortiGate is listening in 443 in the IP you have configured")
    except requests.ConnectTimeout:
        print("Connection timeout")

#Parse incidents attributes from incident.xml
def xml_parser(fileName):
    tree = xml.parse(fileName)
    root = tree.getroot()
    parsed_data = {}

    for element in root.iter(tag='entry'):
        if element.attrib['attribute'] == 'srcIpAddr':
            parsed_data['source_ip']=element.text
        elif element.attrib['attribute'] =='hashCode':
            parsed_data['hash_code']=element.text
        #print element.text
    return parsed_data

def delete_remote_file(hostname,username,password,hashcode):
    try:
        s = pxssh.pxssh()
        s.login(hostname, username, password)
        command='for file in $(find '+base_directory+' -type f -exec md5sum {} + | egrep '+hashcode+' |awk \'{ print $2 }\');do ls -l --time=atime $file && rm -fv $file && echo $file has been deleted >> /tmp/deleted.files.log;done'
        print command
#        command='for file in $(find '+base_directory+' -type f -exec md5sum {} + | egrep '+hashcode+'$|awk \'{ print $2 }\');do echo removed $file;done'
        s.sendline(command)   # run a command
        s.prompt()
        result = ''.join(s.before.splitlines())
        print "response from server: "+result        
        if 'removed' in result:
             logging.debug(hashcode +' has been removed from '+ hostname)
        else:
             logging.debug(hashcode +' doesn t exist on '+ hostname + ' file system')

        s.logout()

    except pxssh.ExceptionPxssh as e:
        print("ssh failed on login.")
        print(e)

def main():
    data = {}
    data=xml_parser(sys.argv[1])
    

    hash_code = ''.join(data['hash_code'].splitlines())
    source_ip = ''.join(data['source_ip'].splitlines())
    source_ip = re.findall( r'[0-9]+(?:\.[0-9]+){3}', source_ip )
    logging.debug(hash_code+' '+source_ip[0])
    if hash_code != 1:
        delete_remote_file(server_ip,server_username,server_password,hash_code)
    if source_ip != 1:
        ban_ip(fgt_ip,source_ip[0])   
    

if __name__ == "__main__":
    main()
